import {
  RouterContext,
  require_browser
} from "./chunk-QZ2ZOA3G.js";
import {
  pathToRegexp
} from "./chunk-2MCQLR4F.js";
import {
  require_jsx_runtime
} from "./chunk-L7VO4W5A.js";
import {
  require_react
} from "./chunk-AW4LUYTZ.js";
import {
  __toESM
} from "./chunk-SNAQBZPT.js";

// node_modules/@toolpad/core/shared/Link.js
var React = __toESM(require_react());
var import_jsx_runtime = __toESM(require_jsx_runtime());
var Link = React.forwardRef(function Link2(props, ref) {
  const {
    children,
    href,
    onClick,
    history,
    ...rest
  } = props;
  const routerContext = React.useContext(RouterContext);
  const handleLinkClick = React.useMemo(() => {
    if (!routerContext) {
      return onClick;
    }
    return (event) => {
      event.preventDefault();
      const url = new URL(event.currentTarget.href);
      routerContext.navigate(url.pathname, {
        history
      });
      onClick == null ? void 0 : onClick(event);
    };
  }, [routerContext, onClick, history]);
  return (0, import_jsx_runtime.jsx)("a", {
    ref,
    href,
    ...rest,
    onClick: handleLinkClick,
    children
  });
});

// node_modules/@toolpad/core/shared/navigation.js
var import_invariant = __toESM(require_browser());
var getItemKind = (item) => item.kind ?? "page";
var isPageItem = (item) => getItemKind(item) === "page";
var getItemTitle = (item) => {
  return isPageItem(item) ? item.title ?? item.segment ?? "" : item.title;
};
function getPageItemFullPath(basePath, navigationItem) {
  return `${basePath}${basePath && !navigationItem.segment ? "" : "/"}${navigationItem.segment ?? ""}`;
}
function isPageItemSelected(navigationItem, basePath, pathname) {
  return navigationItem.pattern ? pathToRegexp(`${basePath}/${navigationItem.pattern}`).test(pathname) : getPageItemFullPath(basePath, navigationItem) === pathname;
}
function hasSelectedNavigationChildren(navigationItem, basePath, pathname) {
  if (isPageItem(navigationItem) && navigationItem.children) {
    const navigationItemFullPath = getPageItemFullPath(basePath, navigationItem);
    return navigationItem.children.some((nestedNavigationItem) => {
      if (!isPageItem(nestedNavigationItem)) {
        return false;
      }
      if (nestedNavigationItem.children) {
        return hasSelectedNavigationChildren(nestedNavigationItem, navigationItemFullPath, pathname);
      }
      return isPageItemSelected(nestedNavigationItem, navigationItemFullPath, pathname);
    });
  }
  return false;
}
function buildItemToPathMap(navigation) {
  const map = /* @__PURE__ */ new Map();
  const visit = (item, base) => {
    if (isPageItem(item)) {
      const path = `${base}${item.segment ? `/${item.segment}` : ""}` || "/";
      map.set(item, path);
      if (item.children) {
        for (const child of item.children) {
          visit(child, path);
        }
      }
    }
  };
  for (const item of navigation) {
    visit(item, "");
  }
  return map;
}
var itemToPathMapCache = /* @__PURE__ */ new WeakMap();
function getItemToPathMap(navigation) {
  let map = itemToPathMapCache.get(navigation);
  if (!map) {
    map = buildItemToPathMap(navigation);
    itemToPathMapCache.set(navigation, map);
  }
  return map;
}
function buildItemLookup(navigation) {
  const map = /* @__PURE__ */ new Map();
  const visit = (item) => {
    if (isPageItem(item)) {
      const path = getItemPath(navigation, item);
      if (map.has(path)) {
        console.warn(`Duplicate path in navigation: ${path}`);
      }
      map.set(path, item);
      if (item.pattern) {
        const basePath = item.segment ? path.slice(0, -item.segment.length) : path;
        map.set(pathToRegexp(basePath + item.pattern), item);
      }
      if (item.children) {
        for (const child of item.children) {
          visit(child);
        }
      }
    }
  };
  for (const item of navigation) {
    visit(item);
  }
  return map;
}
var itemLookupMapCache = /* @__PURE__ */ new WeakMap();
function getItemLookup(navigation) {
  let map = itemLookupMapCache.get(navigation);
  if (!map) {
    map = buildItemLookup(navigation);
    itemLookupMapCache.set(navigation, map);
  }
  return map;
}
function matchPath(navigation, path) {
  const lookup = getItemLookup(navigation);
  for (const [key, item] of lookup.entries()) {
    if (typeof key === "string" && key === path) {
      return item;
    }
    if (key instanceof RegExp && key.test(path)) {
      return item;
    }
  }
  return null;
}
function getItemPath(navigation, item) {
  const map = getItemToPathMap(navigation);
  const path = map.get(item);
  (0, import_invariant.default)(path, `Item not found in navigation: ${item.title}`);
  return path;
}

export {
  Link,
  getItemTitle,
  getPageItemFullPath,
  isPageItemSelected,
  hasSelectedNavigationChildren,
  matchPath,
  getItemPath
};
//# sourceMappingURL=chunk-XPOC6QMH.js.map
